// Generated by jextract

package pl.lemanski.mikroaudio.internal;

import com.v7878.foreign.*;
import com.v7878.foreign.ValueLayout.OfByte;
import com.v7878.foreign.ValueLayout.OfInt;
import java.util.function.*;

import static com.v7878.foreign.MemoryLayout.PathElement.groupElement;

/**
 * {@snippet lang=c :
 * struct ma_device_config {
 *     ma_device_type deviceType;
 *     ma_uint32 sampleRate;
 *     ma_uint32 periodSizeInFrames;
 *     ma_uint32 periodSizeInMilliseconds;
 *     ma_uint32 periods;
 *     ma_performance_profile performanceProfile;
 *     ma_bool8 noPreSilencedOutputBuffer;
 *     ma_bool8 noClip;
 *     ma_bool8 noDisableDenormals;
 *     ma_bool8 noFixedSizedCallback;
 *     ma_device_data_proc dataCallback;
 *     ma_device_notification_proc notificationCallback;
 *     ma_stop_proc stopCallback;
 *     void *pUserData;
 *     ma_resampler_config resampling;
 *     struct {
 *         const ma_device_id *pDeviceID;
 *         ma_format format;
 *         ma_uint32 channels;
 *         ma_channel *pChannelMap;
 *         ma_channel_mix_mode channelMixMode;
 *         ma_bool32 calculateLFEFromSpatialChannels;
 *         ma_share_mode shareMode;
 *     } playback;
 *     struct {
 *         const ma_device_id *pDeviceID;
 *         ma_format format;
 *         ma_uint32 channels;
 *         ma_channel *pChannelMap;
 *         ma_channel_mix_mode channelMixMode;
 *         ma_bool32 calculateLFEFromSpatialChannels;
 *         ma_share_mode shareMode;
 *     } capture;
 *     struct {
 *         ma_wasapi_usage usage;
 *         ma_bool8 noAutoConvertSRC;
 *         ma_bool8 noDefaultQualitySRC;
 *         ma_bool8 noAutoStreamRouting;
 *         ma_bool8 noHardwareOffloading;
 *         ma_uint32 loopbackProcessID;
 *         ma_bool8 loopbackProcessExclude;
 *     } wasapi;
 *     struct {
 *         ma_bool32 noMMap;
 *         ma_bool32 noAutoFormat;
 *         ma_bool32 noAutoChannels;
 *         ma_bool32 noAutoResample;
 *     } alsa;
 *     struct {
 *         const char *pStreamNamePlayback;
 *         const char *pStreamNameCapture;
 *     } pulse;
 *     struct {
 *         ma_bool32 allowNominalSampleRateChange;
 *     } coreaudio;
 *     struct {
 *         ma_opensl_stream_type streamType;
 *         ma_opensl_recording_preset recordingPreset;
 *         ma_bool32 enableCompatibilityWorkarounds;
 *     } opensl;
 *     struct {
 *         ma_aaudio_usage usage;
 *         ma_aaudio_content_type contentType;
 *         ma_aaudio_input_preset inputPreset;
 *         ma_aaudio_allowed_capture_policy allowedCapturePolicy;
 *         ma_bool32 noAutoStartAfterReroute;
 *         ma_bool32 enableCompatibilityWorkarounds;
 *     } aaudio;
 * }
 * }
 */
public class ma_device_config {

    ma_device_config() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        miniaudio_h.C_INT.withName("deviceType"),
        miniaudio_h.C_INT.withName("sampleRate"),
        miniaudio_h.C_INT.withName("periodSizeInFrames"),
        miniaudio_h.C_INT.withName("periodSizeInMilliseconds"),
        miniaudio_h.C_INT.withName("periods"),
        miniaudio_h.C_INT.withName("performanceProfile"),
        miniaudio_h.C_CHAR.withName("noPreSilencedOutputBuffer"),
        miniaudio_h.C_CHAR.withName("noClip"),
        miniaudio_h.C_CHAR.withName("noDisableDenormals"),
        miniaudio_h.C_CHAR.withName("noFixedSizedCallback"),
        MemoryLayout.paddingLayout(4),
        miniaudio_h.C_POINTER.withName("dataCallback"),
        miniaudio_h.C_POINTER.withName("notificationCallback"),
        miniaudio_h.C_POINTER.withName("stopCallback"),
        miniaudio_h.C_POINTER.withName("pUserData"),
        ma_resampler_config.layout().withName("resampling"),
        playback.layout().withName("playback"),
        capture.layout().withName("capture"),
        wasapi.layout().withName("wasapi"),
        alsa.layout().withName("alsa"),
        pulse.layout().withName("pulse"),
        coreaudio.layout().withName("coreaudio"),
        opensl.layout().withName("opensl"),
        aaudio.layout().withName("aaudio")
    ).withName("ma_device_config");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt deviceType$LAYOUT = (OfInt)$LAYOUT.select(groupElement("deviceType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_device_type deviceType
     * }
     */
    public static final OfInt deviceType$layout() {
        return deviceType$LAYOUT;
    }

    private static final long deviceType$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_device_type deviceType
     * }
     */
    public static final long deviceType$offset() {
        return deviceType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_device_type deviceType
     * }
     */
    public static int deviceType(MemorySegment struct) {
        return struct.get(deviceType$LAYOUT, deviceType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_device_type deviceType
     * }
     */
    public static void deviceType(MemorySegment struct, int fieldValue) {
        struct.set(deviceType$LAYOUT, deviceType$OFFSET, fieldValue);
    }

    private static final OfInt sampleRate$LAYOUT = (OfInt)$LAYOUT.select(groupElement("sampleRate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_uint32 sampleRate
     * }
     */
    public static final OfInt sampleRate$layout() {
        return sampleRate$LAYOUT;
    }

    private static final long sampleRate$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_uint32 sampleRate
     * }
     */
    public static final long sampleRate$offset() {
        return sampleRate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_uint32 sampleRate
     * }
     */
    public static int sampleRate(MemorySegment struct) {
        return struct.get(sampleRate$LAYOUT, sampleRate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_uint32 sampleRate
     * }
     */
    public static void sampleRate(MemorySegment struct, int fieldValue) {
        struct.set(sampleRate$LAYOUT, sampleRate$OFFSET, fieldValue);
    }

    private static final OfInt periodSizeInFrames$LAYOUT = (OfInt)$LAYOUT.select(groupElement("periodSizeInFrames"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_uint32 periodSizeInFrames
     * }
     */
    public static final OfInt periodSizeInFrames$layout() {
        return periodSizeInFrames$LAYOUT;
    }

    private static final long periodSizeInFrames$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_uint32 periodSizeInFrames
     * }
     */
    public static final long periodSizeInFrames$offset() {
        return periodSizeInFrames$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_uint32 periodSizeInFrames
     * }
     */
    public static int periodSizeInFrames(MemorySegment struct) {
        return struct.get(periodSizeInFrames$LAYOUT, periodSizeInFrames$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_uint32 periodSizeInFrames
     * }
     */
    public static void periodSizeInFrames(MemorySegment struct, int fieldValue) {
        struct.set(periodSizeInFrames$LAYOUT, periodSizeInFrames$OFFSET, fieldValue);
    }

    private static final OfInt periodSizeInMilliseconds$LAYOUT = (OfInt)$LAYOUT.select(groupElement("periodSizeInMilliseconds"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_uint32 periodSizeInMilliseconds
     * }
     */
    public static final OfInt periodSizeInMilliseconds$layout() {
        return periodSizeInMilliseconds$LAYOUT;
    }

    private static final long periodSizeInMilliseconds$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_uint32 periodSizeInMilliseconds
     * }
     */
    public static final long periodSizeInMilliseconds$offset() {
        return periodSizeInMilliseconds$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_uint32 periodSizeInMilliseconds
     * }
     */
    public static int periodSizeInMilliseconds(MemorySegment struct) {
        return struct.get(periodSizeInMilliseconds$LAYOUT, periodSizeInMilliseconds$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_uint32 periodSizeInMilliseconds
     * }
     */
    public static void periodSizeInMilliseconds(MemorySegment struct, int fieldValue) {
        struct.set(periodSizeInMilliseconds$LAYOUT, periodSizeInMilliseconds$OFFSET, fieldValue);
    }

    private static final OfInt periods$LAYOUT = (OfInt)$LAYOUT.select(groupElement("periods"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_uint32 periods
     * }
     */
    public static final OfInt periods$layout() {
        return periods$LAYOUT;
    }

    private static final long periods$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_uint32 periods
     * }
     */
    public static final long periods$offset() {
        return periods$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_uint32 periods
     * }
     */
    public static int periods(MemorySegment struct) {
        return struct.get(periods$LAYOUT, periods$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_uint32 periods
     * }
     */
    public static void periods(MemorySegment struct, int fieldValue) {
        struct.set(periods$LAYOUT, periods$OFFSET, fieldValue);
    }

    private static final OfInt performanceProfile$LAYOUT = (OfInt)$LAYOUT.select(groupElement("performanceProfile"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_performance_profile performanceProfile
     * }
     */
    public static final OfInt performanceProfile$layout() {
        return performanceProfile$LAYOUT;
    }

    private static final long performanceProfile$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_performance_profile performanceProfile
     * }
     */
    public static final long performanceProfile$offset() {
        return performanceProfile$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_performance_profile performanceProfile
     * }
     */
    public static int performanceProfile(MemorySegment struct) {
        return struct.get(performanceProfile$LAYOUT, performanceProfile$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_performance_profile performanceProfile
     * }
     */
    public static void performanceProfile(MemorySegment struct, int fieldValue) {
        struct.set(performanceProfile$LAYOUT, performanceProfile$OFFSET, fieldValue);
    }

    private static final OfByte noPreSilencedOutputBuffer$LAYOUT = (OfByte)$LAYOUT.select(groupElement("noPreSilencedOutputBuffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_bool8 noPreSilencedOutputBuffer
     * }
     */
    public static final OfByte noPreSilencedOutputBuffer$layout() {
        return noPreSilencedOutputBuffer$LAYOUT;
    }

    private static final long noPreSilencedOutputBuffer$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_bool8 noPreSilencedOutputBuffer
     * }
     */
    public static final long noPreSilencedOutputBuffer$offset() {
        return noPreSilencedOutputBuffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_bool8 noPreSilencedOutputBuffer
     * }
     */
    public static byte noPreSilencedOutputBuffer(MemorySegment struct) {
        return struct.get(noPreSilencedOutputBuffer$LAYOUT, noPreSilencedOutputBuffer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_bool8 noPreSilencedOutputBuffer
     * }
     */
    public static void noPreSilencedOutputBuffer(MemorySegment struct, byte fieldValue) {
        struct.set(noPreSilencedOutputBuffer$LAYOUT, noPreSilencedOutputBuffer$OFFSET, fieldValue);
    }

    private static final OfByte noClip$LAYOUT = (OfByte)$LAYOUT.select(groupElement("noClip"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_bool8 noClip
     * }
     */
    public static final OfByte noClip$layout() {
        return noClip$LAYOUT;
    }

    private static final long noClip$OFFSET = 25;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_bool8 noClip
     * }
     */
    public static final long noClip$offset() {
        return noClip$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_bool8 noClip
     * }
     */
    public static byte noClip(MemorySegment struct) {
        return struct.get(noClip$LAYOUT, noClip$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_bool8 noClip
     * }
     */
    public static void noClip(MemorySegment struct, byte fieldValue) {
        struct.set(noClip$LAYOUT, noClip$OFFSET, fieldValue);
    }

    private static final OfByte noDisableDenormals$LAYOUT = (OfByte)$LAYOUT.select(groupElement("noDisableDenormals"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_bool8 noDisableDenormals
     * }
     */
    public static final OfByte noDisableDenormals$layout() {
        return noDisableDenormals$LAYOUT;
    }

    private static final long noDisableDenormals$OFFSET = 26;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_bool8 noDisableDenormals
     * }
     */
    public static final long noDisableDenormals$offset() {
        return noDisableDenormals$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_bool8 noDisableDenormals
     * }
     */
    public static byte noDisableDenormals(MemorySegment struct) {
        return struct.get(noDisableDenormals$LAYOUT, noDisableDenormals$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_bool8 noDisableDenormals
     * }
     */
    public static void noDisableDenormals(MemorySegment struct, byte fieldValue) {
        struct.set(noDisableDenormals$LAYOUT, noDisableDenormals$OFFSET, fieldValue);
    }

    private static final OfByte noFixedSizedCallback$LAYOUT = (OfByte)$LAYOUT.select(groupElement("noFixedSizedCallback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_bool8 noFixedSizedCallback
     * }
     */
    public static final OfByte noFixedSizedCallback$layout() {
        return noFixedSizedCallback$LAYOUT;
    }

    private static final long noFixedSizedCallback$OFFSET = 27;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_bool8 noFixedSizedCallback
     * }
     */
    public static final long noFixedSizedCallback$offset() {
        return noFixedSizedCallback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_bool8 noFixedSizedCallback
     * }
     */
    public static byte noFixedSizedCallback(MemorySegment struct) {
        return struct.get(noFixedSizedCallback$LAYOUT, noFixedSizedCallback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_bool8 noFixedSizedCallback
     * }
     */
    public static void noFixedSizedCallback(MemorySegment struct, byte fieldValue) {
        struct.set(noFixedSizedCallback$LAYOUT, noFixedSizedCallback$OFFSET, fieldValue);
    }

    private static final AddressLayout dataCallback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("dataCallback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_device_data_proc dataCallback
     * }
     */
    public static final AddressLayout dataCallback$layout() {
        return dataCallback$LAYOUT;
    }

    private static final long dataCallback$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_device_data_proc dataCallback
     * }
     */
    public static final long dataCallback$offset() {
        return dataCallback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_device_data_proc dataCallback
     * }
     */
    public static MemorySegment dataCallback(MemorySegment struct) {
        return struct.get(dataCallback$LAYOUT, dataCallback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_device_data_proc dataCallback
     * }
     */
    public static void dataCallback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(dataCallback$LAYOUT, dataCallback$OFFSET, fieldValue);
    }

    private static final AddressLayout notificationCallback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("notificationCallback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_device_notification_proc notificationCallback
     * }
     */
    public static final AddressLayout notificationCallback$layout() {
        return notificationCallback$LAYOUT;
    }

    private static final long notificationCallback$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_device_notification_proc notificationCallback
     * }
     */
    public static final long notificationCallback$offset() {
        return notificationCallback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_device_notification_proc notificationCallback
     * }
     */
    public static MemorySegment notificationCallback(MemorySegment struct) {
        return struct.get(notificationCallback$LAYOUT, notificationCallback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_device_notification_proc notificationCallback
     * }
     */
    public static void notificationCallback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(notificationCallback$LAYOUT, notificationCallback$OFFSET, fieldValue);
    }

    private static final AddressLayout stopCallback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("stopCallback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_stop_proc stopCallback
     * }
     */
    public static final AddressLayout stopCallback$layout() {
        return stopCallback$LAYOUT;
    }

    private static final long stopCallback$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_stop_proc stopCallback
     * }
     */
    public static final long stopCallback$offset() {
        return stopCallback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_stop_proc stopCallback
     * }
     */
    public static MemorySegment stopCallback(MemorySegment struct) {
        return struct.get(stopCallback$LAYOUT, stopCallback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_stop_proc stopCallback
     * }
     */
    public static void stopCallback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(stopCallback$LAYOUT, stopCallback$OFFSET, fieldValue);
    }

    private static final AddressLayout pUserData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pUserData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *pUserData
     * }
     */
    public static final AddressLayout pUserData$layout() {
        return pUserData$LAYOUT;
    }

    private static final long pUserData$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *pUserData
     * }
     */
    public static final long pUserData$offset() {
        return pUserData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *pUserData
     * }
     */
    public static MemorySegment pUserData(MemorySegment struct) {
        return struct.get(pUserData$LAYOUT, pUserData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *pUserData
     * }
     */
    public static void pUserData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pUserData$LAYOUT, pUserData$OFFSET, fieldValue);
    }

    private static final GroupLayout resampling$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("resampling"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_resampler_config resampling
     * }
     */
    public static final GroupLayout resampling$layout() {
        return resampling$LAYOUT;
    }

    private static final long resampling$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_resampler_config resampling
     * }
     */
    public static final long resampling$offset() {
        return resampling$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_resampler_config resampling
     * }
     */
    public static MemorySegment resampling(MemorySegment struct) {
        return struct.asSlice(resampling$OFFSET, resampling$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_resampler_config resampling
     * }
     */
    public static void resampling(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, resampling$OFFSET, resampling$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     const ma_device_id *pDeviceID;
     *     ma_format format;
     *     ma_uint32 channels;
     *     ma_channel *pChannelMap;
     *     ma_channel_mix_mode channelMixMode;
     *     ma_bool32 calculateLFEFromSpatialChannels;
     *     ma_share_mode shareMode;
     * }
     * }
     */
    public static class playback {

        playback() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            miniaudio_h.C_POINTER.withName("pDeviceID"),
            miniaudio_h.C_INT.withName("format"),
            miniaudio_h.C_INT.withName("channels"),
            miniaudio_h.C_POINTER.withName("pChannelMap"),
            miniaudio_h.C_INT.withName("channelMixMode"),
            miniaudio_h.C_INT.withName("calculateLFEFromSpatialChannels"),
            miniaudio_h.C_INT.withName("shareMode"),
            MemoryLayout.paddingLayout(4)
        ).withName("$anon$7054:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout pDeviceID$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pDeviceID"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * const ma_device_id *pDeviceID
         * }
         */
        public static final AddressLayout pDeviceID$layout() {
            return pDeviceID$LAYOUT;
        }

        private static final long pDeviceID$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * const ma_device_id *pDeviceID
         * }
         */
        public static final long pDeviceID$offset() {
            return pDeviceID$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * const ma_device_id *pDeviceID
         * }
         */
        public static MemorySegment pDeviceID(MemorySegment struct) {
            return struct.get(pDeviceID$LAYOUT, pDeviceID$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * const ma_device_id *pDeviceID
         * }
         */
        public static void pDeviceID(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(pDeviceID$LAYOUT, pDeviceID$OFFSET, fieldValue);
        }

        private static final OfInt format$LAYOUT = (OfInt)$LAYOUT.select(groupElement("format"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_format format
         * }
         */
        public static final OfInt format$layout() {
            return format$LAYOUT;
        }

        private static final long format$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_format format
         * }
         */
        public static final long format$offset() {
            return format$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_format format
         * }
         */
        public static int format(MemorySegment struct) {
            return struct.get(format$LAYOUT, format$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_format format
         * }
         */
        public static void format(MemorySegment struct, int fieldValue) {
            struct.set(format$LAYOUT, format$OFFSET, fieldValue);
        }

        private static final OfInt channels$LAYOUT = (OfInt)$LAYOUT.select(groupElement("channels"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_uint32 channels
         * }
         */
        public static final OfInt channels$layout() {
            return channels$LAYOUT;
        }

        private static final long channels$OFFSET = 12;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_uint32 channels
         * }
         */
        public static final long channels$offset() {
            return channels$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_uint32 channels
         * }
         */
        public static int channels(MemorySegment struct) {
            return struct.get(channels$LAYOUT, channels$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_uint32 channels
         * }
         */
        public static void channels(MemorySegment struct, int fieldValue) {
            struct.set(channels$LAYOUT, channels$OFFSET, fieldValue);
        }

        private static final AddressLayout pChannelMap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pChannelMap"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_channel *pChannelMap
         * }
         */
        public static final AddressLayout pChannelMap$layout() {
            return pChannelMap$LAYOUT;
        }

        private static final long pChannelMap$OFFSET = 16;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_channel *pChannelMap
         * }
         */
        public static final long pChannelMap$offset() {
            return pChannelMap$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_channel *pChannelMap
         * }
         */
        public static MemorySegment pChannelMap(MemorySegment struct) {
            return struct.get(pChannelMap$LAYOUT, pChannelMap$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_channel *pChannelMap
         * }
         */
        public static void pChannelMap(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(pChannelMap$LAYOUT, pChannelMap$OFFSET, fieldValue);
        }

        private static final OfInt channelMixMode$LAYOUT = (OfInt)$LAYOUT.select(groupElement("channelMixMode"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_channel_mix_mode channelMixMode
         * }
         */
        public static final OfInt channelMixMode$layout() {
            return channelMixMode$LAYOUT;
        }

        private static final long channelMixMode$OFFSET = 24;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_channel_mix_mode channelMixMode
         * }
         */
        public static final long channelMixMode$offset() {
            return channelMixMode$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_channel_mix_mode channelMixMode
         * }
         */
        public static int channelMixMode(MemorySegment struct) {
            return struct.get(channelMixMode$LAYOUT, channelMixMode$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_channel_mix_mode channelMixMode
         * }
         */
        public static void channelMixMode(MemorySegment struct, int fieldValue) {
            struct.set(channelMixMode$LAYOUT, channelMixMode$OFFSET, fieldValue);
        }

        private static final OfInt calculateLFEFromSpatialChannels$LAYOUT = (OfInt)$LAYOUT.select(groupElement("calculateLFEFromSpatialChannels"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool32 calculateLFEFromSpatialChannels
         * }
         */
        public static final OfInt calculateLFEFromSpatialChannels$layout() {
            return calculateLFEFromSpatialChannels$LAYOUT;
        }

        private static final long calculateLFEFromSpatialChannels$OFFSET = 28;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool32 calculateLFEFromSpatialChannels
         * }
         */
        public static final long calculateLFEFromSpatialChannels$offset() {
            return calculateLFEFromSpatialChannels$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool32 calculateLFEFromSpatialChannels
         * }
         */
        public static int calculateLFEFromSpatialChannels(MemorySegment struct) {
            return struct.get(calculateLFEFromSpatialChannels$LAYOUT, calculateLFEFromSpatialChannels$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool32 calculateLFEFromSpatialChannels
         * }
         */
        public static void calculateLFEFromSpatialChannels(MemorySegment struct, int fieldValue) {
            struct.set(calculateLFEFromSpatialChannels$LAYOUT, calculateLFEFromSpatialChannels$OFFSET, fieldValue);
        }

        private static final OfInt shareMode$LAYOUT = (OfInt)$LAYOUT.select(groupElement("shareMode"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_share_mode shareMode
         * }
         */
        public static final OfInt shareMode$layout() {
            return shareMode$LAYOUT;
        }

        private static final long shareMode$OFFSET = 32;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_share_mode shareMode
         * }
         */
        public static final long shareMode$offset() {
            return shareMode$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_share_mode shareMode
         * }
         */
        public static int shareMode(MemorySegment struct) {
            return struct.get(shareMode$LAYOUT, shareMode$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_share_mode shareMode
         * }
         */
        public static void shareMode(MemorySegment struct, int fieldValue) {
            struct.set(shareMode$LAYOUT, shareMode$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout playback$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("playback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     const ma_device_id *pDeviceID;
     *     ma_format format;
     *     ma_uint32 channels;
     *     ma_channel *pChannelMap;
     *     ma_channel_mix_mode channelMixMode;
     *     ma_bool32 calculateLFEFromSpatialChannels;
     *     ma_share_mode shareMode;
     * } playback
     * }
     */
    public static final GroupLayout playback$layout() {
        return playback$LAYOUT;
    }

    private static final long playback$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     const ma_device_id *pDeviceID;
     *     ma_format format;
     *     ma_uint32 channels;
     *     ma_channel *pChannelMap;
     *     ma_channel_mix_mode channelMixMode;
     *     ma_bool32 calculateLFEFromSpatialChannels;
     *     ma_share_mode shareMode;
     * } playback
     * }
     */
    public static final long playback$offset() {
        return playback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     const ma_device_id *pDeviceID;
     *     ma_format format;
     *     ma_uint32 channels;
     *     ma_channel *pChannelMap;
     *     ma_channel_mix_mode channelMixMode;
     *     ma_bool32 calculateLFEFromSpatialChannels;
     *     ma_share_mode shareMode;
     * } playback
     * }
     */
    public static MemorySegment playback(MemorySegment struct) {
        return struct.asSlice(playback$OFFSET, playback$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     const ma_device_id *pDeviceID;
     *     ma_format format;
     *     ma_uint32 channels;
     *     ma_channel *pChannelMap;
     *     ma_channel_mix_mode channelMixMode;
     *     ma_bool32 calculateLFEFromSpatialChannels;
     *     ma_share_mode shareMode;
     * } playback
     * }
     */
    public static void playback(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, playback$OFFSET, playback$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     const ma_device_id *pDeviceID;
     *     ma_format format;
     *     ma_uint32 channels;
     *     ma_channel *pChannelMap;
     *     ma_channel_mix_mode channelMixMode;
     *     ma_bool32 calculateLFEFromSpatialChannels;
     *     ma_share_mode shareMode;
     * }
     * }
     */
    public static class capture {

        capture() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            miniaudio_h.C_POINTER.withName("pDeviceID"),
            miniaudio_h.C_INT.withName("format"),
            miniaudio_h.C_INT.withName("channels"),
            miniaudio_h.C_POINTER.withName("pChannelMap"),
            miniaudio_h.C_INT.withName("channelMixMode"),
            miniaudio_h.C_INT.withName("calculateLFEFromSpatialChannels"),
            miniaudio_h.C_INT.withName("shareMode"),
            MemoryLayout.paddingLayout(4)
        ).withName("$anon$7064:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout pDeviceID$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pDeviceID"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * const ma_device_id *pDeviceID
         * }
         */
        public static final AddressLayout pDeviceID$layout() {
            return pDeviceID$LAYOUT;
        }

        private static final long pDeviceID$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * const ma_device_id *pDeviceID
         * }
         */
        public static final long pDeviceID$offset() {
            return pDeviceID$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * const ma_device_id *pDeviceID
         * }
         */
        public static MemorySegment pDeviceID(MemorySegment struct) {
            return struct.get(pDeviceID$LAYOUT, pDeviceID$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * const ma_device_id *pDeviceID
         * }
         */
        public static void pDeviceID(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(pDeviceID$LAYOUT, pDeviceID$OFFSET, fieldValue);
        }

        private static final OfInt format$LAYOUT = (OfInt)$LAYOUT.select(groupElement("format"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_format format
         * }
         */
        public static final OfInt format$layout() {
            return format$LAYOUT;
        }

        private static final long format$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_format format
         * }
         */
        public static final long format$offset() {
            return format$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_format format
         * }
         */
        public static int format(MemorySegment struct) {
            return struct.get(format$LAYOUT, format$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_format format
         * }
         */
        public static void format(MemorySegment struct, int fieldValue) {
            struct.set(format$LAYOUT, format$OFFSET, fieldValue);
        }

        private static final OfInt channels$LAYOUT = (OfInt)$LAYOUT.select(groupElement("channels"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_uint32 channels
         * }
         */
        public static final OfInt channels$layout() {
            return channels$LAYOUT;
        }

        private static final long channels$OFFSET = 12;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_uint32 channels
         * }
         */
        public static final long channels$offset() {
            return channels$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_uint32 channels
         * }
         */
        public static int channels(MemorySegment struct) {
            return struct.get(channels$LAYOUT, channels$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_uint32 channels
         * }
         */
        public static void channels(MemorySegment struct, int fieldValue) {
            struct.set(channels$LAYOUT, channels$OFFSET, fieldValue);
        }

        private static final AddressLayout pChannelMap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pChannelMap"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_channel *pChannelMap
         * }
         */
        public static final AddressLayout pChannelMap$layout() {
            return pChannelMap$LAYOUT;
        }

        private static final long pChannelMap$OFFSET = 16;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_channel *pChannelMap
         * }
         */
        public static final long pChannelMap$offset() {
            return pChannelMap$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_channel *pChannelMap
         * }
         */
        public static MemorySegment pChannelMap(MemorySegment struct) {
            return struct.get(pChannelMap$LAYOUT, pChannelMap$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_channel *pChannelMap
         * }
         */
        public static void pChannelMap(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(pChannelMap$LAYOUT, pChannelMap$OFFSET, fieldValue);
        }

        private static final OfInt channelMixMode$LAYOUT = (OfInt)$LAYOUT.select(groupElement("channelMixMode"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_channel_mix_mode channelMixMode
         * }
         */
        public static final OfInt channelMixMode$layout() {
            return channelMixMode$LAYOUT;
        }

        private static final long channelMixMode$OFFSET = 24;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_channel_mix_mode channelMixMode
         * }
         */
        public static final long channelMixMode$offset() {
            return channelMixMode$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_channel_mix_mode channelMixMode
         * }
         */
        public static int channelMixMode(MemorySegment struct) {
            return struct.get(channelMixMode$LAYOUT, channelMixMode$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_channel_mix_mode channelMixMode
         * }
         */
        public static void channelMixMode(MemorySegment struct, int fieldValue) {
            struct.set(channelMixMode$LAYOUT, channelMixMode$OFFSET, fieldValue);
        }

        private static final OfInt calculateLFEFromSpatialChannels$LAYOUT = (OfInt)$LAYOUT.select(groupElement("calculateLFEFromSpatialChannels"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool32 calculateLFEFromSpatialChannels
         * }
         */
        public static final OfInt calculateLFEFromSpatialChannels$layout() {
            return calculateLFEFromSpatialChannels$LAYOUT;
        }

        private static final long calculateLFEFromSpatialChannels$OFFSET = 28;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool32 calculateLFEFromSpatialChannels
         * }
         */
        public static final long calculateLFEFromSpatialChannels$offset() {
            return calculateLFEFromSpatialChannels$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool32 calculateLFEFromSpatialChannels
         * }
         */
        public static int calculateLFEFromSpatialChannels(MemorySegment struct) {
            return struct.get(calculateLFEFromSpatialChannels$LAYOUT, calculateLFEFromSpatialChannels$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool32 calculateLFEFromSpatialChannels
         * }
         */
        public static void calculateLFEFromSpatialChannels(MemorySegment struct, int fieldValue) {
            struct.set(calculateLFEFromSpatialChannels$LAYOUT, calculateLFEFromSpatialChannels$OFFSET, fieldValue);
        }

        private static final OfInt shareMode$LAYOUT = (OfInt)$LAYOUT.select(groupElement("shareMode"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_share_mode shareMode
         * }
         */
        public static final OfInt shareMode$layout() {
            return shareMode$LAYOUT;
        }

        private static final long shareMode$OFFSET = 32;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_share_mode shareMode
         * }
         */
        public static final long shareMode$offset() {
            return shareMode$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_share_mode shareMode
         * }
         */
        public static int shareMode(MemorySegment struct) {
            return struct.get(shareMode$LAYOUT, shareMode$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_share_mode shareMode
         * }
         */
        public static void shareMode(MemorySegment struct, int fieldValue) {
            struct.set(shareMode$LAYOUT, shareMode$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout capture$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("capture"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     const ma_device_id *pDeviceID;
     *     ma_format format;
     *     ma_uint32 channels;
     *     ma_channel *pChannelMap;
     *     ma_channel_mix_mode channelMixMode;
     *     ma_bool32 calculateLFEFromSpatialChannels;
     *     ma_share_mode shareMode;
     * } capture
     * }
     */
    public static final GroupLayout capture$layout() {
        return capture$LAYOUT;
    }

    private static final long capture$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     const ma_device_id *pDeviceID;
     *     ma_format format;
     *     ma_uint32 channels;
     *     ma_channel *pChannelMap;
     *     ma_channel_mix_mode channelMixMode;
     *     ma_bool32 calculateLFEFromSpatialChannels;
     *     ma_share_mode shareMode;
     * } capture
     * }
     */
    public static final long capture$offset() {
        return capture$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     const ma_device_id *pDeviceID;
     *     ma_format format;
     *     ma_uint32 channels;
     *     ma_channel *pChannelMap;
     *     ma_channel_mix_mode channelMixMode;
     *     ma_bool32 calculateLFEFromSpatialChannels;
     *     ma_share_mode shareMode;
     * } capture
     * }
     */
    public static MemorySegment capture(MemorySegment struct) {
        return struct.asSlice(capture$OFFSET, capture$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     const ma_device_id *pDeviceID;
     *     ma_format format;
     *     ma_uint32 channels;
     *     ma_channel *pChannelMap;
     *     ma_channel_mix_mode channelMixMode;
     *     ma_bool32 calculateLFEFromSpatialChannels;
     *     ma_share_mode shareMode;
     * } capture
     * }
     */
    public static void capture(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, capture$OFFSET, capture$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ma_wasapi_usage usage;
     *     ma_bool8 noAutoConvertSRC;
     *     ma_bool8 noDefaultQualitySRC;
     *     ma_bool8 noAutoStreamRouting;
     *     ma_bool8 noHardwareOffloading;
     *     ma_uint32 loopbackProcessID;
     *     ma_bool8 loopbackProcessExclude;
     * }
     * }
     */
    public static class wasapi {

        wasapi() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            miniaudio_h.C_INT.withName("usage"),
            miniaudio_h.C_CHAR.withName("noAutoConvertSRC"),
            miniaudio_h.C_CHAR.withName("noDefaultQualitySRC"),
            miniaudio_h.C_CHAR.withName("noAutoStreamRouting"),
            miniaudio_h.C_CHAR.withName("noHardwareOffloading"),
            miniaudio_h.C_INT.withName("loopbackProcessID"),
            miniaudio_h.C_CHAR.withName("loopbackProcessExclude"),
            MemoryLayout.paddingLayout(3)
        ).withName("$anon$7075:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt usage$LAYOUT = (OfInt)$LAYOUT.select(groupElement("usage"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_wasapi_usage usage
         * }
         */
        public static final OfInt usage$layout() {
            return usage$LAYOUT;
        }

        private static final long usage$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_wasapi_usage usage
         * }
         */
        public static final long usage$offset() {
            return usage$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_wasapi_usage usage
         * }
         */
        public static int usage(MemorySegment struct) {
            return struct.get(usage$LAYOUT, usage$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_wasapi_usage usage
         * }
         */
        public static void usage(MemorySegment struct, int fieldValue) {
            struct.set(usage$LAYOUT, usage$OFFSET, fieldValue);
        }

        private static final OfByte noAutoConvertSRC$LAYOUT = (OfByte)$LAYOUT.select(groupElement("noAutoConvertSRC"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool8 noAutoConvertSRC
         * }
         */
        public static final OfByte noAutoConvertSRC$layout() {
            return noAutoConvertSRC$LAYOUT;
        }

        private static final long noAutoConvertSRC$OFFSET = 4;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool8 noAutoConvertSRC
         * }
         */
        public static final long noAutoConvertSRC$offset() {
            return noAutoConvertSRC$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool8 noAutoConvertSRC
         * }
         */
        public static byte noAutoConvertSRC(MemorySegment struct) {
            return struct.get(noAutoConvertSRC$LAYOUT, noAutoConvertSRC$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool8 noAutoConvertSRC
         * }
         */
        public static void noAutoConvertSRC(MemorySegment struct, byte fieldValue) {
            struct.set(noAutoConvertSRC$LAYOUT, noAutoConvertSRC$OFFSET, fieldValue);
        }

        private static final OfByte noDefaultQualitySRC$LAYOUT = (OfByte)$LAYOUT.select(groupElement("noDefaultQualitySRC"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool8 noDefaultQualitySRC
         * }
         */
        public static final OfByte noDefaultQualitySRC$layout() {
            return noDefaultQualitySRC$LAYOUT;
        }

        private static final long noDefaultQualitySRC$OFFSET = 5;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool8 noDefaultQualitySRC
         * }
         */
        public static final long noDefaultQualitySRC$offset() {
            return noDefaultQualitySRC$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool8 noDefaultQualitySRC
         * }
         */
        public static byte noDefaultQualitySRC(MemorySegment struct) {
            return struct.get(noDefaultQualitySRC$LAYOUT, noDefaultQualitySRC$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool8 noDefaultQualitySRC
         * }
         */
        public static void noDefaultQualitySRC(MemorySegment struct, byte fieldValue) {
            struct.set(noDefaultQualitySRC$LAYOUT, noDefaultQualitySRC$OFFSET, fieldValue);
        }

        private static final OfByte noAutoStreamRouting$LAYOUT = (OfByte)$LAYOUT.select(groupElement("noAutoStreamRouting"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool8 noAutoStreamRouting
         * }
         */
        public static final OfByte noAutoStreamRouting$layout() {
            return noAutoStreamRouting$LAYOUT;
        }

        private static final long noAutoStreamRouting$OFFSET = 6;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool8 noAutoStreamRouting
         * }
         */
        public static final long noAutoStreamRouting$offset() {
            return noAutoStreamRouting$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool8 noAutoStreamRouting
         * }
         */
        public static byte noAutoStreamRouting(MemorySegment struct) {
            return struct.get(noAutoStreamRouting$LAYOUT, noAutoStreamRouting$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool8 noAutoStreamRouting
         * }
         */
        public static void noAutoStreamRouting(MemorySegment struct, byte fieldValue) {
            struct.set(noAutoStreamRouting$LAYOUT, noAutoStreamRouting$OFFSET, fieldValue);
        }

        private static final OfByte noHardwareOffloading$LAYOUT = (OfByte)$LAYOUT.select(groupElement("noHardwareOffloading"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool8 noHardwareOffloading
         * }
         */
        public static final OfByte noHardwareOffloading$layout() {
            return noHardwareOffloading$LAYOUT;
        }

        private static final long noHardwareOffloading$OFFSET = 7;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool8 noHardwareOffloading
         * }
         */
        public static final long noHardwareOffloading$offset() {
            return noHardwareOffloading$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool8 noHardwareOffloading
         * }
         */
        public static byte noHardwareOffloading(MemorySegment struct) {
            return struct.get(noHardwareOffloading$LAYOUT, noHardwareOffloading$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool8 noHardwareOffloading
         * }
         */
        public static void noHardwareOffloading(MemorySegment struct, byte fieldValue) {
            struct.set(noHardwareOffloading$LAYOUT, noHardwareOffloading$OFFSET, fieldValue);
        }

        private static final OfInt loopbackProcessID$LAYOUT = (OfInt)$LAYOUT.select(groupElement("loopbackProcessID"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_uint32 loopbackProcessID
         * }
         */
        public static final OfInt loopbackProcessID$layout() {
            return loopbackProcessID$LAYOUT;
        }

        private static final long loopbackProcessID$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_uint32 loopbackProcessID
         * }
         */
        public static final long loopbackProcessID$offset() {
            return loopbackProcessID$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_uint32 loopbackProcessID
         * }
         */
        public static int loopbackProcessID(MemorySegment struct) {
            return struct.get(loopbackProcessID$LAYOUT, loopbackProcessID$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_uint32 loopbackProcessID
         * }
         */
        public static void loopbackProcessID(MemorySegment struct, int fieldValue) {
            struct.set(loopbackProcessID$LAYOUT, loopbackProcessID$OFFSET, fieldValue);
        }

        private static final OfByte loopbackProcessExclude$LAYOUT = (OfByte)$LAYOUT.select(groupElement("loopbackProcessExclude"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool8 loopbackProcessExclude
         * }
         */
        public static final OfByte loopbackProcessExclude$layout() {
            return loopbackProcessExclude$LAYOUT;
        }

        private static final long loopbackProcessExclude$OFFSET = 12;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool8 loopbackProcessExclude
         * }
         */
        public static final long loopbackProcessExclude$offset() {
            return loopbackProcessExclude$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool8 loopbackProcessExclude
         * }
         */
        public static byte loopbackProcessExclude(MemorySegment struct) {
            return struct.get(loopbackProcessExclude$LAYOUT, loopbackProcessExclude$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool8 loopbackProcessExclude
         * }
         */
        public static void loopbackProcessExclude(MemorySegment struct, byte fieldValue) {
            struct.set(loopbackProcessExclude$LAYOUT, loopbackProcessExclude$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout wasapi$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("wasapi"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ma_wasapi_usage usage;
     *     ma_bool8 noAutoConvertSRC;
     *     ma_bool8 noDefaultQualitySRC;
     *     ma_bool8 noAutoStreamRouting;
     *     ma_bool8 noHardwareOffloading;
     *     ma_uint32 loopbackProcessID;
     *     ma_bool8 loopbackProcessExclude;
     * } wasapi
     * }
     */
    public static final GroupLayout wasapi$layout() {
        return wasapi$LAYOUT;
    }

    private static final long wasapi$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ma_wasapi_usage usage;
     *     ma_bool8 noAutoConvertSRC;
     *     ma_bool8 noDefaultQualitySRC;
     *     ma_bool8 noAutoStreamRouting;
     *     ma_bool8 noHardwareOffloading;
     *     ma_uint32 loopbackProcessID;
     *     ma_bool8 loopbackProcessExclude;
     * } wasapi
     * }
     */
    public static final long wasapi$offset() {
        return wasapi$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ma_wasapi_usage usage;
     *     ma_bool8 noAutoConvertSRC;
     *     ma_bool8 noDefaultQualitySRC;
     *     ma_bool8 noAutoStreamRouting;
     *     ma_bool8 noHardwareOffloading;
     *     ma_uint32 loopbackProcessID;
     *     ma_bool8 loopbackProcessExclude;
     * } wasapi
     * }
     */
    public static MemorySegment wasapi(MemorySegment struct) {
        return struct.asSlice(wasapi$OFFSET, wasapi$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ma_wasapi_usage usage;
     *     ma_bool8 noAutoConvertSRC;
     *     ma_bool8 noDefaultQualitySRC;
     *     ma_bool8 noAutoStreamRouting;
     *     ma_bool8 noHardwareOffloading;
     *     ma_uint32 loopbackProcessID;
     *     ma_bool8 loopbackProcessExclude;
     * } wasapi
     * }
     */
    public static void wasapi(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, wasapi$OFFSET, wasapi$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ma_bool32 noMMap;
     *     ma_bool32 noAutoFormat;
     *     ma_bool32 noAutoChannels;
     *     ma_bool32 noAutoResample;
     * }
     * }
     */
    public static class alsa {

        alsa() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            miniaudio_h.C_INT.withName("noMMap"),
            miniaudio_h.C_INT.withName("noAutoFormat"),
            miniaudio_h.C_INT.withName("noAutoChannels"),
            miniaudio_h.C_INT.withName("noAutoResample")
        ).withName("$anon$7085:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt noMMap$LAYOUT = (OfInt)$LAYOUT.select(groupElement("noMMap"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool32 noMMap
         * }
         */
        public static final OfInt noMMap$layout() {
            return noMMap$LAYOUT;
        }

        private static final long noMMap$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool32 noMMap
         * }
         */
        public static final long noMMap$offset() {
            return noMMap$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool32 noMMap
         * }
         */
        public static int noMMap(MemorySegment struct) {
            return struct.get(noMMap$LAYOUT, noMMap$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool32 noMMap
         * }
         */
        public static void noMMap(MemorySegment struct, int fieldValue) {
            struct.set(noMMap$LAYOUT, noMMap$OFFSET, fieldValue);
        }

        private static final OfInt noAutoFormat$LAYOUT = (OfInt)$LAYOUT.select(groupElement("noAutoFormat"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoFormat
         * }
         */
        public static final OfInt noAutoFormat$layout() {
            return noAutoFormat$LAYOUT;
        }

        private static final long noAutoFormat$OFFSET = 4;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoFormat
         * }
         */
        public static final long noAutoFormat$offset() {
            return noAutoFormat$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoFormat
         * }
         */
        public static int noAutoFormat(MemorySegment struct) {
            return struct.get(noAutoFormat$LAYOUT, noAutoFormat$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoFormat
         * }
         */
        public static void noAutoFormat(MemorySegment struct, int fieldValue) {
            struct.set(noAutoFormat$LAYOUT, noAutoFormat$OFFSET, fieldValue);
        }

        private static final OfInt noAutoChannels$LAYOUT = (OfInt)$LAYOUT.select(groupElement("noAutoChannels"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoChannels
         * }
         */
        public static final OfInt noAutoChannels$layout() {
            return noAutoChannels$LAYOUT;
        }

        private static final long noAutoChannels$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoChannels
         * }
         */
        public static final long noAutoChannels$offset() {
            return noAutoChannels$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoChannels
         * }
         */
        public static int noAutoChannels(MemorySegment struct) {
            return struct.get(noAutoChannels$LAYOUT, noAutoChannels$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoChannels
         * }
         */
        public static void noAutoChannels(MemorySegment struct, int fieldValue) {
            struct.set(noAutoChannels$LAYOUT, noAutoChannels$OFFSET, fieldValue);
        }

        private static final OfInt noAutoResample$LAYOUT = (OfInt)$LAYOUT.select(groupElement("noAutoResample"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoResample
         * }
         */
        public static final OfInt noAutoResample$layout() {
            return noAutoResample$LAYOUT;
        }

        private static final long noAutoResample$OFFSET = 12;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoResample
         * }
         */
        public static final long noAutoResample$offset() {
            return noAutoResample$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoResample
         * }
         */
        public static int noAutoResample(MemorySegment struct) {
            return struct.get(noAutoResample$LAYOUT, noAutoResample$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoResample
         * }
         */
        public static void noAutoResample(MemorySegment struct, int fieldValue) {
            struct.set(noAutoResample$LAYOUT, noAutoResample$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout alsa$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("alsa"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ma_bool32 noMMap;
     *     ma_bool32 noAutoFormat;
     *     ma_bool32 noAutoChannels;
     *     ma_bool32 noAutoResample;
     * } alsa
     * }
     */
    public static final GroupLayout alsa$layout() {
        return alsa$LAYOUT;
    }

    private static final long alsa$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ma_bool32 noMMap;
     *     ma_bool32 noAutoFormat;
     *     ma_bool32 noAutoChannels;
     *     ma_bool32 noAutoResample;
     * } alsa
     * }
     */
    public static final long alsa$offset() {
        return alsa$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ma_bool32 noMMap;
     *     ma_bool32 noAutoFormat;
     *     ma_bool32 noAutoChannels;
     *     ma_bool32 noAutoResample;
     * } alsa
     * }
     */
    public static MemorySegment alsa(MemorySegment struct) {
        return struct.asSlice(alsa$OFFSET, alsa$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ma_bool32 noMMap;
     *     ma_bool32 noAutoFormat;
     *     ma_bool32 noAutoChannels;
     *     ma_bool32 noAutoResample;
     * } alsa
     * }
     */
    public static void alsa(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, alsa$OFFSET, alsa$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     const char *pStreamNamePlayback;
     *     const char *pStreamNameCapture;
     * }
     * }
     */
    public static class pulse {

        pulse() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            miniaudio_h.C_POINTER.withName("pStreamNamePlayback"),
            miniaudio_h.C_POINTER.withName("pStreamNameCapture")
        ).withName("$anon$7092:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout pStreamNamePlayback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pStreamNamePlayback"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * const char *pStreamNamePlayback
         * }
         */
        public static final AddressLayout pStreamNamePlayback$layout() {
            return pStreamNamePlayback$LAYOUT;
        }

        private static final long pStreamNamePlayback$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * const char *pStreamNamePlayback
         * }
         */
        public static final long pStreamNamePlayback$offset() {
            return pStreamNamePlayback$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * const char *pStreamNamePlayback
         * }
         */
        public static MemorySegment pStreamNamePlayback(MemorySegment struct) {
            return struct.get(pStreamNamePlayback$LAYOUT, pStreamNamePlayback$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * const char *pStreamNamePlayback
         * }
         */
        public static void pStreamNamePlayback(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(pStreamNamePlayback$LAYOUT, pStreamNamePlayback$OFFSET, fieldValue);
        }

        private static final AddressLayout pStreamNameCapture$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pStreamNameCapture"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * const char *pStreamNameCapture
         * }
         */
        public static final AddressLayout pStreamNameCapture$layout() {
            return pStreamNameCapture$LAYOUT;
        }

        private static final long pStreamNameCapture$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * const char *pStreamNameCapture
         * }
         */
        public static final long pStreamNameCapture$offset() {
            return pStreamNameCapture$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * const char *pStreamNameCapture
         * }
         */
        public static MemorySegment pStreamNameCapture(MemorySegment struct) {
            return struct.get(pStreamNameCapture$LAYOUT, pStreamNameCapture$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * const char *pStreamNameCapture
         * }
         */
        public static void pStreamNameCapture(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(pStreamNameCapture$LAYOUT, pStreamNameCapture$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout pulse$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("pulse"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     const char *pStreamNamePlayback;
     *     const char *pStreamNameCapture;
     * } pulse
     * }
     */
    public static final GroupLayout pulse$layout() {
        return pulse$LAYOUT;
    }

    private static final long pulse$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     const char *pStreamNamePlayback;
     *     const char *pStreamNameCapture;
     * } pulse
     * }
     */
    public static final long pulse$offset() {
        return pulse$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     const char *pStreamNamePlayback;
     *     const char *pStreamNameCapture;
     * } pulse
     * }
     */
    public static MemorySegment pulse(MemorySegment struct) {
        return struct.asSlice(pulse$OFFSET, pulse$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     const char *pStreamNamePlayback;
     *     const char *pStreamNameCapture;
     * } pulse
     * }
     */
    public static void pulse(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, pulse$OFFSET, pulse$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ma_bool32 allowNominalSampleRateChange;
     * }
     * }
     */
    public static class coreaudio {

        coreaudio() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            miniaudio_h.C_INT.withName("allowNominalSampleRateChange")
        ).withName("$anon$7097:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt allowNominalSampleRateChange$LAYOUT = (OfInt)$LAYOUT.select(groupElement("allowNominalSampleRateChange"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool32 allowNominalSampleRateChange
         * }
         */
        public static final OfInt allowNominalSampleRateChange$layout() {
            return allowNominalSampleRateChange$LAYOUT;
        }

        private static final long allowNominalSampleRateChange$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool32 allowNominalSampleRateChange
         * }
         */
        public static final long allowNominalSampleRateChange$offset() {
            return allowNominalSampleRateChange$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool32 allowNominalSampleRateChange
         * }
         */
        public static int allowNominalSampleRateChange(MemorySegment struct) {
            return struct.get(allowNominalSampleRateChange$LAYOUT, allowNominalSampleRateChange$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool32 allowNominalSampleRateChange
         * }
         */
        public static void allowNominalSampleRateChange(MemorySegment struct, int fieldValue) {
            struct.set(allowNominalSampleRateChange$LAYOUT, allowNominalSampleRateChange$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout coreaudio$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("coreaudio"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ma_bool32 allowNominalSampleRateChange;
     * } coreaudio
     * }
     */
    public static final GroupLayout coreaudio$layout() {
        return coreaudio$LAYOUT;
    }

    private static final long coreaudio$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ma_bool32 allowNominalSampleRateChange;
     * } coreaudio
     * }
     */
    public static final long coreaudio$offset() {
        return coreaudio$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ma_bool32 allowNominalSampleRateChange;
     * } coreaudio
     * }
     */
    public static MemorySegment coreaudio(MemorySegment struct) {
        return struct.asSlice(coreaudio$OFFSET, coreaudio$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ma_bool32 allowNominalSampleRateChange;
     * } coreaudio
     * }
     */
    public static void coreaudio(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, coreaudio$OFFSET, coreaudio$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ma_opensl_stream_type streamType;
     *     ma_opensl_recording_preset recordingPreset;
     *     ma_bool32 enableCompatibilityWorkarounds;
     * }
     * }
     */
    public static class opensl {

        opensl() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            miniaudio_h.C_INT.withName("streamType"),
            miniaudio_h.C_INT.withName("recordingPreset"),
            miniaudio_h.C_INT.withName("enableCompatibilityWorkarounds")
        ).withName("$anon$7101:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt streamType$LAYOUT = (OfInt)$LAYOUT.select(groupElement("streamType"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_opensl_stream_type streamType
         * }
         */
        public static final OfInt streamType$layout() {
            return streamType$LAYOUT;
        }

        private static final long streamType$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_opensl_stream_type streamType
         * }
         */
        public static final long streamType$offset() {
            return streamType$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_opensl_stream_type streamType
         * }
         */
        public static int streamType(MemorySegment struct) {
            return struct.get(streamType$LAYOUT, streamType$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_opensl_stream_type streamType
         * }
         */
        public static void streamType(MemorySegment struct, int fieldValue) {
            struct.set(streamType$LAYOUT, streamType$OFFSET, fieldValue);
        }

        private static final OfInt recordingPreset$LAYOUT = (OfInt)$LAYOUT.select(groupElement("recordingPreset"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_opensl_recording_preset recordingPreset
         * }
         */
        public static final OfInt recordingPreset$layout() {
            return recordingPreset$LAYOUT;
        }

        private static final long recordingPreset$OFFSET = 4;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_opensl_recording_preset recordingPreset
         * }
         */
        public static final long recordingPreset$offset() {
            return recordingPreset$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_opensl_recording_preset recordingPreset
         * }
         */
        public static int recordingPreset(MemorySegment struct) {
            return struct.get(recordingPreset$LAYOUT, recordingPreset$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_opensl_recording_preset recordingPreset
         * }
         */
        public static void recordingPreset(MemorySegment struct, int fieldValue) {
            struct.set(recordingPreset$LAYOUT, recordingPreset$OFFSET, fieldValue);
        }

        private static final OfInt enableCompatibilityWorkarounds$LAYOUT = (OfInt)$LAYOUT.select(groupElement("enableCompatibilityWorkarounds"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool32 enableCompatibilityWorkarounds
         * }
         */
        public static final OfInt enableCompatibilityWorkarounds$layout() {
            return enableCompatibilityWorkarounds$LAYOUT;
        }

        private static final long enableCompatibilityWorkarounds$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool32 enableCompatibilityWorkarounds
         * }
         */
        public static final long enableCompatibilityWorkarounds$offset() {
            return enableCompatibilityWorkarounds$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool32 enableCompatibilityWorkarounds
         * }
         */
        public static int enableCompatibilityWorkarounds(MemorySegment struct) {
            return struct.get(enableCompatibilityWorkarounds$LAYOUT, enableCompatibilityWorkarounds$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool32 enableCompatibilityWorkarounds
         * }
         */
        public static void enableCompatibilityWorkarounds(MemorySegment struct, int fieldValue) {
            struct.set(enableCompatibilityWorkarounds$LAYOUT, enableCompatibilityWorkarounds$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout opensl$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("opensl"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ma_opensl_stream_type streamType;
     *     ma_opensl_recording_preset recordingPreset;
     *     ma_bool32 enableCompatibilityWorkarounds;
     * } opensl
     * }
     */
    public static final GroupLayout opensl$layout() {
        return opensl$LAYOUT;
    }

    private static final long opensl$OFFSET = 244;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ma_opensl_stream_type streamType;
     *     ma_opensl_recording_preset recordingPreset;
     *     ma_bool32 enableCompatibilityWorkarounds;
     * } opensl
     * }
     */
    public static final long opensl$offset() {
        return opensl$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ma_opensl_stream_type streamType;
     *     ma_opensl_recording_preset recordingPreset;
     *     ma_bool32 enableCompatibilityWorkarounds;
     * } opensl
     * }
     */
    public static MemorySegment opensl(MemorySegment struct) {
        return struct.asSlice(opensl$OFFSET, opensl$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ma_opensl_stream_type streamType;
     *     ma_opensl_recording_preset recordingPreset;
     *     ma_bool32 enableCompatibilityWorkarounds;
     * } opensl
     * }
     */
    public static void opensl(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, opensl$OFFSET, opensl$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ma_aaudio_usage usage;
     *     ma_aaudio_content_type contentType;
     *     ma_aaudio_input_preset inputPreset;
     *     ma_aaudio_allowed_capture_policy allowedCapturePolicy;
     *     ma_bool32 noAutoStartAfterReroute;
     *     ma_bool32 enableCompatibilityWorkarounds;
     * }
     * }
     */
    public static class aaudio {

        aaudio() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            miniaudio_h.C_INT.withName("usage"),
            miniaudio_h.C_INT.withName("contentType"),
            miniaudio_h.C_INT.withName("inputPreset"),
            miniaudio_h.C_INT.withName("allowedCapturePolicy"),
            miniaudio_h.C_INT.withName("noAutoStartAfterReroute"),
            miniaudio_h.C_INT.withName("enableCompatibilityWorkarounds")
        ).withName("$anon$7107:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt usage$LAYOUT = (OfInt)$LAYOUT.select(groupElement("usage"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_aaudio_usage usage
         * }
         */
        public static final OfInt usage$layout() {
            return usage$LAYOUT;
        }

        private static final long usage$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_aaudio_usage usage
         * }
         */
        public static final long usage$offset() {
            return usage$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_aaudio_usage usage
         * }
         */
        public static int usage(MemorySegment struct) {
            return struct.get(usage$LAYOUT, usage$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_aaudio_usage usage
         * }
         */
        public static void usage(MemorySegment struct, int fieldValue) {
            struct.set(usage$LAYOUT, usage$OFFSET, fieldValue);
        }

        private static final OfInt contentType$LAYOUT = (OfInt)$LAYOUT.select(groupElement("contentType"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_aaudio_content_type contentType
         * }
         */
        public static final OfInt contentType$layout() {
            return contentType$LAYOUT;
        }

        private static final long contentType$OFFSET = 4;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_aaudio_content_type contentType
         * }
         */
        public static final long contentType$offset() {
            return contentType$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_aaudio_content_type contentType
         * }
         */
        public static int contentType(MemorySegment struct) {
            return struct.get(contentType$LAYOUT, contentType$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_aaudio_content_type contentType
         * }
         */
        public static void contentType(MemorySegment struct, int fieldValue) {
            struct.set(contentType$LAYOUT, contentType$OFFSET, fieldValue);
        }

        private static final OfInt inputPreset$LAYOUT = (OfInt)$LAYOUT.select(groupElement("inputPreset"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_aaudio_input_preset inputPreset
         * }
         */
        public static final OfInt inputPreset$layout() {
            return inputPreset$LAYOUT;
        }

        private static final long inputPreset$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_aaudio_input_preset inputPreset
         * }
         */
        public static final long inputPreset$offset() {
            return inputPreset$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_aaudio_input_preset inputPreset
         * }
         */
        public static int inputPreset(MemorySegment struct) {
            return struct.get(inputPreset$LAYOUT, inputPreset$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_aaudio_input_preset inputPreset
         * }
         */
        public static void inputPreset(MemorySegment struct, int fieldValue) {
            struct.set(inputPreset$LAYOUT, inputPreset$OFFSET, fieldValue);
        }

        private static final OfInt allowedCapturePolicy$LAYOUT = (OfInt)$LAYOUT.select(groupElement("allowedCapturePolicy"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_aaudio_allowed_capture_policy allowedCapturePolicy
         * }
         */
        public static final OfInt allowedCapturePolicy$layout() {
            return allowedCapturePolicy$LAYOUT;
        }

        private static final long allowedCapturePolicy$OFFSET = 12;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_aaudio_allowed_capture_policy allowedCapturePolicy
         * }
         */
        public static final long allowedCapturePolicy$offset() {
            return allowedCapturePolicy$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_aaudio_allowed_capture_policy allowedCapturePolicy
         * }
         */
        public static int allowedCapturePolicy(MemorySegment struct) {
            return struct.get(allowedCapturePolicy$LAYOUT, allowedCapturePolicy$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_aaudio_allowed_capture_policy allowedCapturePolicy
         * }
         */
        public static void allowedCapturePolicy(MemorySegment struct, int fieldValue) {
            struct.set(allowedCapturePolicy$LAYOUT, allowedCapturePolicy$OFFSET, fieldValue);
        }

        private static final OfInt noAutoStartAfterReroute$LAYOUT = (OfInt)$LAYOUT.select(groupElement("noAutoStartAfterReroute"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoStartAfterReroute
         * }
         */
        public static final OfInt noAutoStartAfterReroute$layout() {
            return noAutoStartAfterReroute$LAYOUT;
        }

        private static final long noAutoStartAfterReroute$OFFSET = 16;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoStartAfterReroute
         * }
         */
        public static final long noAutoStartAfterReroute$offset() {
            return noAutoStartAfterReroute$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoStartAfterReroute
         * }
         */
        public static int noAutoStartAfterReroute(MemorySegment struct) {
            return struct.get(noAutoStartAfterReroute$LAYOUT, noAutoStartAfterReroute$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool32 noAutoStartAfterReroute
         * }
         */
        public static void noAutoStartAfterReroute(MemorySegment struct, int fieldValue) {
            struct.set(noAutoStartAfterReroute$LAYOUT, noAutoStartAfterReroute$OFFSET, fieldValue);
        }

        private static final OfInt enableCompatibilityWorkarounds$LAYOUT = (OfInt)$LAYOUT.select(groupElement("enableCompatibilityWorkarounds"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_bool32 enableCompatibilityWorkarounds
         * }
         */
        public static final OfInt enableCompatibilityWorkarounds$layout() {
            return enableCompatibilityWorkarounds$LAYOUT;
        }

        private static final long enableCompatibilityWorkarounds$OFFSET = 20;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_bool32 enableCompatibilityWorkarounds
         * }
         */
        public static final long enableCompatibilityWorkarounds$offset() {
            return enableCompatibilityWorkarounds$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_bool32 enableCompatibilityWorkarounds
         * }
         */
        public static int enableCompatibilityWorkarounds(MemorySegment struct) {
            return struct.get(enableCompatibilityWorkarounds$LAYOUT, enableCompatibilityWorkarounds$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_bool32 enableCompatibilityWorkarounds
         * }
         */
        public static void enableCompatibilityWorkarounds(MemorySegment struct, int fieldValue) {
            struct.set(enableCompatibilityWorkarounds$LAYOUT, enableCompatibilityWorkarounds$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout aaudio$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("aaudio"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ma_aaudio_usage usage;
     *     ma_aaudio_content_type contentType;
     *     ma_aaudio_input_preset inputPreset;
     *     ma_aaudio_allowed_capture_policy allowedCapturePolicy;
     *     ma_bool32 noAutoStartAfterReroute;
     *     ma_bool32 enableCompatibilityWorkarounds;
     * } aaudio
     * }
     */
    public static final GroupLayout aaudio$layout() {
        return aaudio$LAYOUT;
    }

    private static final long aaudio$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ma_aaudio_usage usage;
     *     ma_aaudio_content_type contentType;
     *     ma_aaudio_input_preset inputPreset;
     *     ma_aaudio_allowed_capture_policy allowedCapturePolicy;
     *     ma_bool32 noAutoStartAfterReroute;
     *     ma_bool32 enableCompatibilityWorkarounds;
     * } aaudio
     * }
     */
    public static final long aaudio$offset() {
        return aaudio$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ma_aaudio_usage usage;
     *     ma_aaudio_content_type contentType;
     *     ma_aaudio_input_preset inputPreset;
     *     ma_aaudio_allowed_capture_policy allowedCapturePolicy;
     *     ma_bool32 noAutoStartAfterReroute;
     *     ma_bool32 enableCompatibilityWorkarounds;
     * } aaudio
     * }
     */
    public static MemorySegment aaudio(MemorySegment struct) {
        return struct.asSlice(aaudio$OFFSET, aaudio$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ma_aaudio_usage usage;
     *     ma_aaudio_content_type contentType;
     *     ma_aaudio_input_preset inputPreset;
     *     ma_aaudio_allowed_capture_policy allowedCapturePolicy;
     *     ma_bool32 noAutoStartAfterReroute;
     *     ma_bool32 enableCompatibilityWorkarounds;
     * } aaudio
     * }
     */
    public static void aaudio(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, aaudio$OFFSET, aaudio$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

