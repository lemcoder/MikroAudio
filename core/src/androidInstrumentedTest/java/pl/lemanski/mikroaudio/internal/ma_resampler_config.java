// Generated by jextract

package pl.lemanski.mikroaudio.internal;

import com.v7878.foreign.*;
import java.util.function.*;

import static com.v7878.foreign.MemoryLayout.PathElement.groupElement;

/**
 * {@snippet lang=c :
 * struct ma_resampler_config {
 *     ma_format format;
 *     ma_uint32 channels;
 *     ma_uint32 sampleRateIn;
 *     ma_uint32 sampleRateOut;
 *     ma_resample_algorithm algorithm;
 *     ma_resampling_backend_vtable *pBackendVTable;
 *     void *pBackendUserData;
 *     struct {
 *         ma_uint32 lpfOrder;
 *     } linear;
 * }
 * }
 */
public class ma_resampler_config {

    ma_resampler_config() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        miniaudio_h.C_INT.withName("format"),
        miniaudio_h.C_INT.withName("channels"),
        miniaudio_h.C_INT.withName("sampleRateIn"),
        miniaudio_h.C_INT.withName("sampleRateOut"),
        miniaudio_h.C_INT.withName("algorithm"),
        MemoryLayout.paddingLayout(4),
        miniaudio_h.C_POINTER.withName("pBackendVTable"),
        miniaudio_h.C_POINTER.withName("pBackendUserData"),
        linear.layout().withName("linear"),
        MemoryLayout.paddingLayout(4)
    ).withName("ma_resampler_config");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final ValueLayout.OfInt format$LAYOUT = (ValueLayout.OfInt)$LAYOUT.select(groupElement("format"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_format format
     * }
     */
    public static final ValueLayout.OfInt format$layout() {
        return format$LAYOUT;
    }

    private static final long format$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_format format
     * }
     */
    public static final long format$offset() {
        return format$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_format format
     * }
     */
    public static int format(MemorySegment struct) {
        return struct.get(format$LAYOUT, format$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_format format
     * }
     */
    public static void format(MemorySegment struct, int fieldValue) {
        struct.set(format$LAYOUT, format$OFFSET, fieldValue);
    }

    private static final ValueLayout.OfInt channels$LAYOUT = (ValueLayout.OfInt)$LAYOUT.select(groupElement("channels"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_uint32 channels
     * }
     */
    public static final ValueLayout.OfInt channels$layout() {
        return channels$LAYOUT;
    }

    private static final long channels$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_uint32 channels
     * }
     */
    public static final long channels$offset() {
        return channels$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_uint32 channels
     * }
     */
    public static int channels(MemorySegment struct) {
        return struct.get(channels$LAYOUT, channels$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_uint32 channels
     * }
     */
    public static void channels(MemorySegment struct, int fieldValue) {
        struct.set(channels$LAYOUT, channels$OFFSET, fieldValue);
    }

    private static final ValueLayout.OfInt sampleRateIn$LAYOUT = (ValueLayout.OfInt)$LAYOUT.select(groupElement("sampleRateIn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_uint32 sampleRateIn
     * }
     */
    public static final ValueLayout.OfInt sampleRateIn$layout() {
        return sampleRateIn$LAYOUT;
    }

    private static final long sampleRateIn$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_uint32 sampleRateIn
     * }
     */
    public static final long sampleRateIn$offset() {
        return sampleRateIn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_uint32 sampleRateIn
     * }
     */
    public static int sampleRateIn(MemorySegment struct) {
        return struct.get(sampleRateIn$LAYOUT, sampleRateIn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_uint32 sampleRateIn
     * }
     */
    public static void sampleRateIn(MemorySegment struct, int fieldValue) {
        struct.set(sampleRateIn$LAYOUT, sampleRateIn$OFFSET, fieldValue);
    }

    private static final ValueLayout.OfInt sampleRateOut$LAYOUT = (ValueLayout.OfInt)$LAYOUT.select(groupElement("sampleRateOut"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_uint32 sampleRateOut
     * }
     */
    public static final ValueLayout.OfInt sampleRateOut$layout() {
        return sampleRateOut$LAYOUT;
    }

    private static final long sampleRateOut$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_uint32 sampleRateOut
     * }
     */
    public static final long sampleRateOut$offset() {
        return sampleRateOut$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_uint32 sampleRateOut
     * }
     */
    public static int sampleRateOut(MemorySegment struct) {
        return struct.get(sampleRateOut$LAYOUT, sampleRateOut$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_uint32 sampleRateOut
     * }
     */
    public static void sampleRateOut(MemorySegment struct, int fieldValue) {
        struct.set(sampleRateOut$LAYOUT, sampleRateOut$OFFSET, fieldValue);
    }

    private static final ValueLayout.OfInt algorithm$LAYOUT = (ValueLayout.OfInt)$LAYOUT.select(groupElement("algorithm"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_resample_algorithm algorithm
     * }
     */
    public static final ValueLayout.OfInt algorithm$layout() {
        return algorithm$LAYOUT;
    }

    private static final long algorithm$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_resample_algorithm algorithm
     * }
     */
    public static final long algorithm$offset() {
        return algorithm$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_resample_algorithm algorithm
     * }
     */
    public static int algorithm(MemorySegment struct) {
        return struct.get(algorithm$LAYOUT, algorithm$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_resample_algorithm algorithm
     * }
     */
    public static void algorithm(MemorySegment struct, int fieldValue) {
        struct.set(algorithm$LAYOUT, algorithm$OFFSET, fieldValue);
    }

    private static final AddressLayout pBackendVTable$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pBackendVTable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ma_resampling_backend_vtable *pBackendVTable
     * }
     */
    public static final AddressLayout pBackendVTable$layout() {
        return pBackendVTable$LAYOUT;
    }

    private static final long pBackendVTable$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ma_resampling_backend_vtable *pBackendVTable
     * }
     */
    public static final long pBackendVTable$offset() {
        return pBackendVTable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ma_resampling_backend_vtable *pBackendVTable
     * }
     */
    public static MemorySegment pBackendVTable(MemorySegment struct) {
        return struct.get(pBackendVTable$LAYOUT, pBackendVTable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ma_resampling_backend_vtable *pBackendVTable
     * }
     */
    public static void pBackendVTable(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pBackendVTable$LAYOUT, pBackendVTable$OFFSET, fieldValue);
    }

    private static final AddressLayout pBackendUserData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pBackendUserData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *pBackendUserData
     * }
     */
    public static final AddressLayout pBackendUserData$layout() {
        return pBackendUserData$LAYOUT;
    }

    private static final long pBackendUserData$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *pBackendUserData
     * }
     */
    public static final long pBackendUserData$offset() {
        return pBackendUserData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *pBackendUserData
     * }
     */
    public static MemorySegment pBackendUserData(MemorySegment struct) {
        return struct.get(pBackendUserData$LAYOUT, pBackendUserData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *pBackendUserData
     * }
     */
    public static void pBackendUserData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pBackendUserData$LAYOUT, pBackendUserData$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     ma_uint32 lpfOrder;
     * }
     * }
     */
    public static class linear {

        linear() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            miniaudio_h.C_INT.withName("lpfOrder")
        ).withName("$anon$5357:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final ValueLayout.OfInt lpfOrder$LAYOUT = (ValueLayout.OfInt)$LAYOUT.select(groupElement("lpfOrder"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ma_uint32 lpfOrder
         * }
         */
        public static final ValueLayout.OfInt lpfOrder$layout() {
            return lpfOrder$LAYOUT;
        }

        private static final long lpfOrder$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ma_uint32 lpfOrder
         * }
         */
        public static final long lpfOrder$offset() {
            return lpfOrder$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ma_uint32 lpfOrder
         * }
         */
        public static int lpfOrder(MemorySegment struct) {
            return struct.get(lpfOrder$LAYOUT, lpfOrder$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ma_uint32 lpfOrder
         * }
         */
        public static void lpfOrder(MemorySegment struct, int fieldValue) {
            struct.set(lpfOrder$LAYOUT, lpfOrder$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout linear$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("linear"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     ma_uint32 lpfOrder;
     * } linear
     * }
     */
    public static final GroupLayout linear$layout() {
        return linear$LAYOUT;
    }

    private static final long linear$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     ma_uint32 lpfOrder;
     * } linear
     * }
     */
    public static final long linear$offset() {
        return linear$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     ma_uint32 lpfOrder;
     * } linear
     * }
     */
    public static MemorySegment linear(MemorySegment struct) {
        return struct.asSlice(linear$OFFSET, linear$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     ma_uint32 lpfOrder;
     * } linear
     * }
     */
    public static void linear(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, linear$OFFSET, linear$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

